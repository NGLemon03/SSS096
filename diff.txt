1.

@@ -186,51 +186,53 @@ def series_from_pack(data):
        return pd.Series(dtype=float)
    
    # å¦‚æœæ˜¯å­—ä¸²ï¼Œé€²è¡Œé¡å¤–æª¢æŸ¥
    if isinstance(data, str):
        if data == "" or data == "[]":
            return pd.Series(dtype=float)
        # Series ä¹Ÿå…ˆè©¦ split
        for orient in ("split", None):
            try:
                kw = {"orient": orient} if orient else {}
                return pd.read_json(io.StringIO(data), typ="series", **kw)
            except Exception:
                pass
        return pd.Series(dtype=float)
    
    if isinstance(data, (list, dict)):
        try:
            return pd.Series(data)
        except Exception:
            return pd.Series(dtype=float)
    
    return pd.Series(dtype=float)

from SSSv096 import (
    param_presets, load_data, compute_single, compute_dual, compute_RMA,
    compute_ssma_turn_combined, backtest_unified, plot_stock_price, plot_equity_cash, plot_weight_series, calculate_holding_periods
    compute_ssma_turn_combined, backtest_unified, plot_stock_price,
    plot_equity_cash, plot_weight_series, calculate_holding_periods,
    calculate_metrics
)

# å½ˆæ€§åŒ¯å…¥ pack_df/pack_series å‡½æ•¸
try:
    from sss_core.schemas import pack_df, pack_series
except Exception:
    from schemas import pack_df, pack_series

# åŒ¯å…¥æ¬Šé‡æ¬„ä½ç¢ºä¿å‡½å¼
try:
    from sss_core.normalize import _ensure_weight_columns
except Exception:
    # å¦‚æœç„¡æ³•åŒ¯å…¥ï¼Œå®šç¾©ä¸€å€‹ç©ºçš„å‡½å¼ä½œç‚º fallback
    def _ensure_weight_columns(df):
        return df

# å‡è¨­ä½ æœ‰ get_version_history_html
try:
    from version_history import get_version_history_html
except ImportError:
    def get_version_history_html() -> str:
        return "<b>ç„¡æ³•è¼‰å…¥ç‰ˆæœ¬æ­·å²è¨˜éŒ„</b>"

# --- ä¿è­‰æ”¾é€² Store çš„éƒ½æ˜¯ JSON-safe ---
def _pack_any(x):
@@ -1215,51 +1217,56 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                atr60 = calculate_atr(df_raw, 60)
                if atr20 is None or atr60 is None:
                    logger.warning(f"[{strat}] ç„¡æ³•è¨ˆç®— ATR20/60ï¼Œè·³éå…¨å±€é¢¨éšªé–¥é–€")
                else:
                    ratio = (atr20 / atr60).replace([np.inf, -np.inf], np.nan)
                    mask = (ratio >= float(atr_ratio))
                    if force_trigger:
                        mask[:] = True  # å¼·åˆ¶å…¨éƒ¨æ—¥å­å¥— CAP

                    # 3) å°é½Šåˆ° ds.indexï¼Œé€æ—¥å£“ w è‡³ CAP
                    mask_aligned = mask.reindex(ds.index).fillna(False).to_numpy()
                    w = ds["w"].astype(float).to_numpy()
                    w_new = w.copy()
                    w_new[mask_aligned] = np.minimum(w_new[mask_aligned], float(risk_cap))
                    ds["w"] = w_new

                    # 4) å›å¯« dsï¼Œä¸¦é‡ç®—äº¤æ˜“/æ¬Šç›Š
                    result["daily_state_std"] = pack_df(ds)

                    # open åƒ¹ï¼ˆæ²’æœ‰ open å°±é€€è€Œæ±‚å…¶æ¬¡ç”¨æ”¶ç›¤åƒ¹ï¼‰
                    open_px = (df_raw["open"] if "open" in df_raw.columns else df_raw.get("æ”¶ç›¤åƒ¹")).astype(float)
                    open_px = open_px.reindex(ds.index).dropna()

                    # è‹¥ä½ æ²¿ç”¨ç¾æœ‰çš„ risk_valve_backtestï¼Œçµ¦ cap_level=1.0 è¡¨ç¤ºã€Œw å·²ç¶“æ˜¯ç›®æ¨™åºåˆ—ã€
                    try:
                        from SSS_EnsembleTab import risk_valve_backtest, CostParams
                        from SSS_EnsembleTab import (
                            risk_valve_backtest,
                            CostParams,
                            build_trade_snapshots_from_ledger,
                            _sell_returns_pct_from_ledger,
                        )
                        
                        # æˆæœ¬åƒæ•¸
                        trade_cost = (strat_params.get("trade_cost", {}) 
                                      if isinstance(strat_params, dict) else {})
                        cost = CostParams(
                            buy_fee_bp=float(trade_cost.get("buy_fee_bp", 4.27)),
                            sell_fee_bp=float(trade_cost.get("sell_fee_bp", 4.27)),
                            sell_tax_bp=float(trade_cost.get("sell_tax_bp", 30.0)),
                        )
                        
                        # åŸºæº–ï¼ˆæœ‰é«˜ä½åƒ¹å°±å¸¶ä¸Šï¼‰
                        bench = pd.DataFrame(index=pd.to_datetime(df_raw.index))
                        if 'close' in df_raw.columns:
                            bench["æ”¶ç›¤åƒ¹"] = pd.to_numeric(df_raw["close"], errors="coerce")
                        elif 'æ”¶ç›¤åƒ¹' in df_raw.columns:
                            bench["æ”¶ç›¤åƒ¹"] = pd.to_numeric(df_raw["æ”¶ç›¤åƒ¹"], errors="coerce")
                        if 'high' in df_raw.columns and 'low' in df_raw.columns:
                            bench["æœ€é«˜åƒ¹"] = pd.to_numeric(df_raw["high"], errors="coerce")
                            bench["æœ€ä½åƒ¹"] = pd.to_numeric(df_raw["low"], errors="coerce")
                        elif 'æœ€é«˜åƒ¹' in df_raw.columns and 'æœ€ä½åƒ¹' in df_raw.columns:
                            bench["æœ€é«˜åƒ¹"] = pd.to_numeric(df_raw["æœ€é«˜åƒ¹"], errors="coerce")
                            bench["æœ€ä½åƒ¹"] = pd.to_numeric(df_raw["æœ€ä½åƒ¹"], errors="coerce")
                        
                        result_cap = risk_valve_backtest(
                            open_px=open_px,
@@ -1275,56 +1282,72 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo

                    if result_cap:
                        # === å®‰å…¨è¦†å¯«ï¼šæ¸…æ‰èˆŠéµä¸¦è£œé½Šæ–°éµ ===
                        logger.info(f"[UI_CHECK] å³å°‡è¦†å¯«ï¼šnew_trades={len(result_cap.get('trade_ledger_valve', pd.DataFrame()))} rows, new_ds={len(result_cap.get('daily_state_valve', pd.DataFrame()))} rows")
                        
                        # 1) è¦†å¯«çµæœ â€”â€” ä¸€å¾‹ç”¨ pack_df/pack_series
                        if 'trade_ledger_valve' in result_cap:
                            result['trades'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger_std'] = pack_df(result_cap['trade_ledger_valve'])
                        
                        if 'daily_state_valve' in result_cap:
                            result['daily_state'] = pack_df(result_cap['daily_state_valve'])
                            result['daily_state_std'] = pack_df(result_cap['daily_state_valve'])
                        
                        if 'weights_valve' in result_cap:
                            result['weight_curve'] = pack_series(result_cap['weights_valve'])
                        
                        # æ¬Šç›Šæ›²ç·šï¼šè‹¥æ˜¯ Series
                        if 'daily_state_valve' in result_cap and 'equity' in result_cap['daily_state_valve']:
                            try:
                                result['equity_curve'] = pack_series(result_cap['daily_state_valve']['equity'])
                            except Exception:
                                # è‹¥ä½ å­˜çš„æ˜¯ DataFrame
                                result['equity_curve'] = pack_df(result_cap['daily_state_valve']['equity'].to_frame('equity'))
                        

                        # 2) **é—œéµ**ï¼šæŠŠ UI å¯èƒ½æ‹¿ä¾†ç”¨çš„èˆŠå¿«å–æ¸…æ‰ï¼Œå¼·è¿« UI èµ°æ–°è³‡æ–™
                        for k in ['trades_ui', 'trade_df', 'trade_ledger_std', 'metrics']:
                            if k in result:
                                result.pop(k, None)
                        

                        # 2025-08-19 ä¿®å¾©ï¼šé¢¨éšªé–¥é–€å¥—ç”¨å¾Œé‡å»ºäº¤æ˜“è³‡æ–™èˆ‡ç¸¾æ•ˆæŒ‡æ¨™ #app_dash.py
                        if 'trade_ledger_valve' in result_cap and 'daily_state_valve' in result_cap:
                            try:
                                trade_df_valve = build_trade_snapshots_from_ledger(result_cap['trade_ledger_valve'])
                                result['trade_df'] = pack_df(trade_df_valve)
                                sell_ret = _sell_returns_pct_from_ledger(result_cap['trade_ledger_valve']) / 100.0
                                trades_list = [(d, r, d) for d, r in sell_ret.items()]
                                equity_valve = result_cap['daily_state_valve']['equity']
                                idx_df = pd.DataFrame(index=equity_valve.index)
                                result['metrics'] = calculate_metrics(trades_list, idx_df, equity_valve)
                            except Exception as e:
                                logger.warning(f"[{strat}] é¢¨éšªé–¥é–€ç¸¾æ•ˆé‡ç®—å¤±æ•—: {e}")
                                result['metrics'] = {}
                        else:
                            result['metrics'] = {}

                        # 3) çµ¦ UI ä¸€å€‹æ——æ¨™èˆ‡åƒæ•¸ï¼Œä¾¿æ–¼é¡¯ç¤ºã€Œå·²å¥—ç”¨ã€
                        result['_risk_valve_applied'] = True
                        result['_risk_valve_params'] = {
                            'cap': float(risk_cap),
                            'atr_ratio': float(atr_ratio),
                            'atr20_last': float(atr_20_valid.iloc[-1]) if len(atr_20_valid) > 0 else None,
                            'atr60_last': float(atr_60_valid.iloc[-1]) if len(atr_60_valid) > 0 else None,
                        }
                        
                        true_days = int(mask_aligned.sum())
                        logger.info(f"[{strat}] å…¨å±€é¢¨éšªé–¥é–€å·²å¥—ç”¨ï¼ˆé€æ—¥ï¼‰ï¼Œé¢¨éšªå¤©æ•¸={true_days}, CAP={risk_cap:.2f}")
                    else:
                        logger.warning(f"[{strat}] é¢¨éšªé–¥é–€é‡ç®—æ²’æœ‰è¿”å›çµæœ")
        
        results[strat] = result
    
    # ä½¿ç”¨ç¬¬ä¸€å€‹ç­–ç•¥çš„æ•¸æ“šä½œç‚ºä¸»è¦é¡¯ç¤ºæ•¸æ“š
    first_strat = list(results.keys())[0] if results else strategy_names[0]
    first_smaa_src = param_presets[first_strat].get("smaa_source", "Self")
    df_raw_main, _ = load_data(ticker, start_date, end_date if end_date else None, smaa_source=first_smaa_src)
    
    # çµ±ä¸€ä½¿ç”¨ orient="split" åºåˆ—åŒ–ï¼Œç¢ºä¿ä¸€è‡´æ€§
    payload = {
        'results': results, 
        'df_raw': df_raw_main.to_json(date_format='iso', orient='split'), 

2.
import dash
from dash import dcc, html, dash_table, Input, Output, State, ctx, no_update
import dash_bootstrap_components as dbc
import pandas as pd
import plotly.graph_objects as go
import json
import io
from dash.dependencies import ALL
import shutil
import os
from datetime import datetime, timedelta
from pathlib import Path
import joblib
from analysis import config as cfg
import yfinance as yf
import logging
import numpy as np
from urllib.parse import quote as urlparse

#app_dash.py
# ä¿®æ”¹ç´€éŒ„:
# 2025-08-19: ä¿®æ­£é¢¨éšªé–¥é–€å¥—ç”¨å¾Œç¸¾æ•ˆæŒ‡æ¨™éºå¤±å•é¡Œï¼Œä¸¦åœ¨çµæœæ§‹å»ºå¾ŒåŠ å…¥é–¥é–€è³‡è¨Š

# é…ç½® logger - ä½¿ç”¨æ–°çš„é¡¯å¼åˆå§‹åŒ–
from analysis.logging_config import init_logging
import os

# å¼·åˆ¶å•Ÿç”¨æª”æ¡ˆæ—¥èªŒï¼Œä¸ä¾è³´ç’°å¢ƒè®Šæ•¸
os.environ["SSS_CREATE_LOGS"] = "1"

# ç›´æ¥å‘¼å« init_loggingï¼Œå®ƒæœƒä½¿ç”¨æ­£ç¢ºçš„æ—¥èªŒç›®éŒ„
init_logging(enable_file=True)
logger = logging.getLogger("SSS.App")

# è¨­å®šç‚º DEBUG ç´šåˆ¥ï¼Œè©³ç´°èª¿è©¦è³‡è¨Šæœƒå¯«å…¥æ—¥èªŒæª”æ¡ˆ
logger.setLevel(logging.DEBUG)
logger.info("å·²å•Ÿç”¨è©³ç´°èª¿è©¦æ¨¡å¼ - èª¿è©¦è³‡è¨Šå°‡å¯«å…¥æ—¥èªŒæª”æ¡ˆ")
logger.info(f"æ—¥èªŒç›®éŒ„: {os.path.abspath('analysis/log')}")

# ATR è¨ˆç®—å‡½æ•¸
def calculate_atr(df, window):
    """è¨ˆç®— ATR (Average True Range)"""
    try:
        # æ”¯æ´å¤šç¨®æ¬„ä½åç¨±æ ¼å¼
        high_col = None
        low_col = None
        close_col = None
        
@@ -868,98 +872,99 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
            result = backtest_unified(df_ind, strat_type, backtest_params, buy_dates, sell_dates, discount=discount, trade_cooldown_bars=cooldown, bad_holding=bad_holding)
            
            # === åœ¨ ssma_turn ä¹Ÿå¥—ç”¨é¢¨éšªé–¥é–€ï¼ˆå’Œ Ensemble ä¸€è‡´çš„å¾Œç½®è¦†å¯«ï¼‰ ===
            if global_apply:
                # åˆ¤æ–·æ˜¯å¦è¦è§¸ç™¼ï¼ˆèˆ‡ä½ çš„ ATR æª¢æŸ¥æˆ–å¼·åˆ¶è§¸ç™¼ä¸€è‡´ï¼‰
                valve_triggered_local = False
                ratio_local = None
                try:
                    atr_20 = calculate_atr(df_raw, 20)
                    atr_60 = calculate_atr(df_raw, 60)
                    if not atr_20.empty and not atr_60.empty:
                        a20 = atr_20.dropna().iloc[-1]
                        a60 = atr_60.dropna().iloc[-1]
                        if a60 > 0:
                            ratio_local = float(a20 / a60)
                            valve_triggered_local = (ratio_local >= atr_ratio)  # å»ºè­°ä½¿ç”¨ >=
                except Exception:
                    pass

                if force_trigger:
                    valve_triggered_local = True
                    if ratio_local is None:
                        ratio_local = 1.5

                if valve_triggered_local:
                    from SSS_EnsembleTab import risk_valve_backtest, CostParams
                    from SSS_EnsembleTab import risk_valve_backtest, CostParams, perf_stats
                    # å–å¾— open åƒ¹ï¼›df_raw æ¬„ä½åç¨±æ˜¯å°å¯«
                    open_px = df_raw['open'] if 'open' in df_raw.columns else df_raw['close']
                    # å¾å›æ¸¬è¼¸å‡ºæŠ“ wï¼ˆå…ˆç”¨æ¨™æº–åŒ– daily_stateï¼Œå¦‚æœæ²’æœ‰å°±ç”¨åŸ daily_stateï¼‰
                    w_series = None
                    try:
                        ds_std = df_from_pack(result.get('daily_state_std'))
                        if ds_std is not None and not ds_std.empty and 'w' in ds_std.columns:
                            w_series = ds_std['w']
                    except Exception:
                        pass
                    if w_series is None:
                        ds = df_from_pack(result.get('daily_state'))
                        if ds is not None and not ds.empty and 'w' in ds.columns:
                            w_series = ds['w']

                    if w_series is not None:
                        # äº¤æ˜“æˆæœ¬ï¼ˆèˆ‡ Ensemble åˆ†æ”¯ä¸€è‡´ï¼‰
                        trade_cost = strat_params.get('trade_cost', {})
                        cost_params = CostParams(
                            buy_fee_bp=float(trade_cost.get("buy_fee_bp", 4.27)),
                            sell_fee_bp=float(trade_cost.get("sell_fee_bp", 4.27)),
                            sell_tax_bp=float(trade_cost.get("sell_tax_bp", 30.0))
                        )

                        rv = risk_valve_backtest(
                            open_px=open_px,
                            w=w_series,
                            cost=cost_params,
                            benchmark_df=df_raw,
                            mode="cap",
                            cap_level=float(risk_cap),
                        )

                        # è¦†å¯«çµæœï¼Œç¢ºä¿ UI èˆ‡è¼¸å‡ºä¸€è‡´ï¼ˆå’Œ Ensemble åˆ†æ”¯å°é½Šï¼‰
                        result['equity_curve']     = pack_series(rv["daily_state_valve"]["equity"])
                        result['daily_state']      = pack_df(rv["daily_state_valve"])
                        result['daily_state_std']  = pack_df(rv["daily_state_valve"])
                        result['trade_ledger']     = pack_df(rv["trade_ledger_valve"])
                        result['trade_ledger_std'] = pack_df(rv["trade_ledger_valve"])
                        result['weight_curve']     = pack_series(rv["weights_valve"])
                        result['metrics']          = perf_stats(rv["daily_state_valve"]["equity"], rv["weights_valve"])
                        # çµ¦ UI çš„æ¨™è¨˜ï¼ˆä¸‹å€‹å°ç¯€æœƒç”¨åˆ°ï¼‰
                        result['valve'] = {
                            "applied": True,
                            "cap": float(risk_cap),
                            "atr_ratio": ratio_local
                        }
                        

                        logger.info(f"[{strat}] SSMA é¢¨éšªé–¥é–€å·²å¥—ç”¨ï¼ˆcap={risk_cap}, ratio={ratio_local:.4f}ï¼‰")
                    else:
                        logger.warning(f"[{strat}] SSMA ç„¡æ³•å–å¾—æ¬Šé‡åºåˆ—ï¼Œè·³éé¢¨éšªé–¥é–€å¥—ç”¨")
                else:
                    logger.info(f"[{strat}] SSMA é¢¨éšªé–¥é–€æœªè§¸ç™¼ï¼Œä½¿ç”¨åŸå§‹çµæœ")
                    # çµ¦ UI çš„æ¨™è¨˜ï¼ˆæœªè§¸ç™¼ï¼‰
                    result['valve'] = {
                        "applied": False,
                        "cap": float(risk_cap),
                        "atr_ratio": ratio_local if ratio_local is not None else "N/A"
                    }
        elif strat_type == 'ensemble':
            # ä½¿ç”¨æ–°çš„ ensemble_runner é¿å…å¾ªç’°ä¾è³´
            try:
                from runners.ensemble_runner import run_ensemble_backtest
                from SSS_EnsembleTab import EnsembleParams, CostParams, RunConfig
                
                # æŠŠ SSSv096 çš„å·¢ç‹€åƒæ•¸æ”¤å¹³
                flat_params = {}
                flat_params.update(strat_params.get('params', {}))
                flat_params.update(strat_params.get('trade_cost', {}))
                flat_params['method'] = strat_params.get('method', 'majority')
                flat_params['ticker'] = ticker
                
                # ä½¿ç”¨æ¯”ä¾‹é–€æª»é¿å… N è®Šå‹•æ™‚å¤±çœŸ
@@ -1048,117 +1053,118 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                                if valve_triggered:
                                    logger.info(f"[{strat}] ğŸ”´ é¢¨éšªé–¥é–€è§¸ç™¼ï¼ATRæ¯”å€¼({ratio:.4f}) > é–€æª»({atr_ratio})")
                                else:
                                    logger.info(f"[{strat}] ğŸŸ¢ é¢¨éšªé–¥é–€æœªè§¸ç™¼ï¼ŒATRæ¯”å€¼({ratio:.4f}) <= é–€æª»({atr_ratio})")
                            else:
                                logger.warning(f"[{strat}] Ensemble ATR(60) å€¼ç‚º 0ï¼Œç„¡æ³•è¨ˆç®—æ¯”å€¼")
                        else:
                            logger.warning(f"[{strat}] Ensemble ATR æ•¸æ“šä¸è¶³")
                    else:
                        logger.warning(f"[{strat}] Ensemble ATR è¨ˆç®—çµæœç‚ºç©º")
                        
                except Exception as e:
                    logger.warning(f"[{strat}] ç„¡æ³•è¨ˆç®— Ensemble ATR æ¯”å€¼: {e}")
                    logger.warning(f"[{strat}] éŒ¯èª¤è©³æƒ…: {type(e).__name__}: {str(e)}")

                # å¦‚æœå•Ÿç”¨å¼·åˆ¶è§¸ç™¼ï¼Œå‰‡å¼·åˆ¶è§¸ç™¼é¢¨éšªé–¥é–€
                if force_trigger:
                    valve_triggered = True
                    logger.info(f"[{strat}] ğŸ”´ å¼·åˆ¶è§¸ç™¼é¢¨éšªé–¥é–€å•Ÿç”¨")
                    if ratio is None:
                        ratio = 1.5  # è¨­å®šä¸€å€‹é è¨­å€¼ç”¨æ–¼é¡¯ç¤º

                # ä½¿ç”¨æ–°çš„ ensemble_runner åŸ·è¡Œ
                backtest_result = run_ensemble_backtest(cfg)

                valve_info = None
                # è‹¥å…¨å±€é–‹é—œé–‹å•Ÿä¸”é”è§¸ç™¼æ¢ä»¶ï¼Œæ‰åœ¨æ¬Šé‡åºåˆ—ä¸Šå¥—ç”¨ CAP
                if global_apply and valve_triggered:
                    from SSS_EnsembleTab import risk_valve_backtest
                    from SSS_EnsembleTab import risk_valve_backtest, perf_stats
                    bench = df_raw  # å·²å« open/high/low/close/volume
                    

                    logger.info(f"[{strat}] ğŸ”´ é–‹å§‹å¥—ç”¨é¢¨éšªé–¥é–€: cap={risk_cap}, ratio={ratio:.4f}")
                    

                    rv = risk_valve_backtest(
                        open_px=backtest_result.price_series,
                        w=backtest_result.weight_curve,
                        cost=cost_params,
                        benchmark_df=bench,
                        mode="cap",
                        cap_level=float(risk_cap),
                    )
                    # è¦†å¯«çµæœï¼Œç¢ºä¿ UI èˆ‡è¼¸å‡ºä¸€è‡´
                    backtest_result.daily_state = rv["daily_state_valve"]
                    backtest_result.ledger = rv["trade_ledger_valve"]
                    backtest_result.weight_curve = rv["weights_valve"]
                    backtest_result.equity_curve = rv["daily_state_valve"]["equity"]
                    backtest_result.stats = perf_stats(backtest_result.equity_curve, backtest_result.weight_curve)
                    logger.info(f"[{strat}] é¢¨éšªé–¥é–€å·²å¥—ç”¨ï¼ˆcap={risk_cap}, ratio={ratio:.4f}ï¼‰")
                    

                    # å¢åŠ é¢¨éšªé–¥é–€æ•ˆæœçš„è©³ç´°è³‡è¨Š
                    if "metrics" in rv:
                        logger.info(f"[{strat}] é¢¨éšªé–¥é–€æ•ˆæœ: PFåŸå§‹={rv['metrics'].get('pf_orig', 'N/A'):.2f}, PFé–¥é–€={rv['metrics'].get('pf_valve', 'N/A'):.2f}")
                        logger.info(f"[{strat}] é¢¨éšªé–¥é–€æ•ˆæœ: MDDåŸå§‹={rv['metrics'].get('mdd_orig', 'N/A'):.2f}%, MDDé–¥é–€={rv['metrics'].get('mdd_valve', 'N/A'):.2f}%")
                    
                    # çµ¦ UI çš„æ¨™è¨˜ï¼ˆèˆ‡ SSMA åˆ†æ”¯å°é½Šï¼‰
                    result['valve'] = {

                    valve_info = {
                        "applied": True,
                        "cap": float(risk_cap),
                        "atr_ratio": ratio
                        "atr_ratio": ratio,
                    }
                else:
                    if global_apply:
                        logger.info(f"[{strat}] ğŸŸ¢ é¢¨éšªé–¥é–€æœªè§¸ç™¼ï¼Œä½¿ç”¨åŸå§‹åƒæ•¸")
                        # çµ¦ UI çš„æ¨™è¨˜ï¼ˆæœªè§¸ç™¼ï¼‰
                        result['valve'] = {
                        valve_info = {
                            "applied": False,
                            "cap": float(risk_cap),
                            "atr_ratio": ratio if ratio is not None else "N/A"
                            "atr_ratio": ratio if ratio is not None else "N/A",
                        }
                    else:
                        logger.info(f"[{strat}] âšª å…¨å±€é¢¨éšªé–¥é–€æœªå•Ÿç”¨")
                        # çµ¦ UI çš„æ¨™è¨˜ï¼ˆæœªå•Ÿç”¨ï¼‰
                        result['valve'] = {
                        valve_info = {
                            "applied": False,
                            "cap": "N/A",
                            "atr_ratio": "N/A"
                            "atr_ratio": "N/A",
                        }
                

                # è½‰æ›ç‚ºèˆŠæ ¼å¼ä»¥ä¿æŒç›¸å®¹æ€§
                result = {
                    'trades': [],
                    'trade_df': pack_df(backtest_result.trades),
                    'trades_df': pack_df(backtest_result.trades),
                    'signals_df': pack_df(backtest_result.trades[['trade_date', 'type', 'price']].rename(columns={'type': 'action'}) if not backtest_result.trades.empty else pd.DataFrame(columns=['trade_date', 'action', 'price'])),
                    'metrics': backtest_result.stats,
                    'equity_curve': pack_series(backtest_result.equity_curve),
                    'cash_curve': pack_series(backtest_result.cash_curve) if backtest_result.cash_curve is not None else "",
                    'weight_curve': pack_series(backtest_result.weight_curve) if backtest_result.weight_curve is not None else pack_series(pd.Series(0.0, index=backtest_result.equity_curve.index)),
                    'price_series': pack_series(backtest_result.price_series) if backtest_result.price_series is not None else pack_series(pd.Series(1.0, index=backtest_result.equity_curve.index)),
                    'daily_state': pack_df(backtest_result.daily_state),
                    'trade_ledger': pack_df(backtest_result.ledger),
                    'daily_state_std': pack_df(backtest_result.daily_state),
                    'trade_ledger_std': pack_df(backtest_result.ledger)
                }
                if valve_info is not None:
                    result['valve'] = valve_info
                
                logger.info(f"[Ensemble] åŸ·è¡ŒæˆåŠŸ: æ¬Šç›Šæ›²ç·šé•·åº¦={len(backtest_result.equity_curve)}, äº¤æ˜“æ•¸={len(backtest_result.ledger) if backtest_result.ledger is not None and not backtest_result.ledger.empty else 0}")
                
            except Exception as e:
                logger.error(f"Ensemble ç­–ç•¥åŸ·è¡Œå¤±æ•—: {e}")
                # å‰µå»ºç©ºçš„çµæœ
                result = {
                    'trades': [],
                    'trade_df': pd.DataFrame(),
                    'trades_df': pd.DataFrame(),
                    'signals_df': pd.DataFrame(),
                    'metrics': {'total_return': 0.0, 'annual_return': 0.0, 'max_drawdown': 0.0, 'sharpe_ratio': 0.0, 'calmar_ratio': 0.0, 'num_trades': 0},
                    'equity_curve': pd.Series(1.0, index=df_raw.index)
                }
            
            # === ä¿®å¾© 3ï¼šæ·»åŠ èª¿è©¦æ—¥èªŒï¼Œæ ¸å°å­ç­–ç•¥é›†åˆæ˜¯å¦ä¸€è‡´ ===
            logger.info(f"[Ensemble] åŸ·è¡Œå®Œæˆï¼Œticker={ticker}, method={flat_params.get('method')}")
            if 'equity_curve' in result and hasattr(result['equity_curve'], 'shape'):
                logger.info(f"[Ensemble] æ¬Šç›Šæ›²ç·šé•·åº¦: {len(result['equity_curve'])}")
            if 'trade_df' in result and hasattr(result['trade_df'], 'shape'):
                logger.info(f"[Ensemble] äº¤æ˜“è¨˜éŒ„æ•¸é‡: {len(result['trade_df'])}")
        else:
            if strat_type == 'single':
                df_ind = compute_single(df_raw, df_factor, strat_params["linlen"], strat_params["factor"], strat_params["smaalen"], strat_params["devwin"], smaa_source=smaa_src)
            elif strat_type == 'dual':
3.
@@ -1280,50 +1280,61 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                        # 1) è¦†å¯«çµæœ â€”â€” ä¸€å¾‹ç”¨ pack_df/pack_series
                        if 'trade_ledger_valve' in result_cap:
                            result['trades'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger_std'] = pack_df(result_cap['trade_ledger_valve'])
                        
                        if 'daily_state_valve' in result_cap:
                            result['daily_state'] = pack_df(result_cap['daily_state_valve'])
                            result['daily_state_std'] = pack_df(result_cap['daily_state_valve'])
                        
                        if 'weights_valve' in result_cap:
                            result['weight_curve'] = pack_series(result_cap['weights_valve'])
                        
                        # æ¬Šç›Šæ›²ç·šï¼šè‹¥æ˜¯ Series
                        if 'daily_state_valve' in result_cap and 'equity' in result_cap['daily_state_valve']:
                            try:
                                result['equity_curve'] = pack_series(result_cap['daily_state_valve']['equity'])
                            except Exception:
                                # è‹¥ä½ å­˜çš„æ˜¯ DataFrame
                                result['equity_curve'] = pack_df(result_cap['daily_state_valve']['equity'].to_frame('equity'))
                        
                        # 2) **é—œéµ**ï¼šæŠŠ UI å¯èƒ½æ‹¿ä¾†ç”¨çš„èˆŠå¿«å–æ¸…æ‰ï¼Œå¼·è¿« UI èµ°æ–°è³‡æ–™
                        for k in ['trades_ui', 'trade_df', 'trade_ledger_std', 'metrics']:
                            if k in result:
                                result.pop(k, None)
                        # 2025-08-20 ä¿®å¾©ï¼šé‡ç®—ç¸¾æ•ˆæŒ‡æ¨™é¿å…æ¸…ç©ºå¾Œåƒ…å‰©å¹³å‡æŒå€‰å¤©æ•¸
                        try:
                            from SSS_EnsembleTab import perf_stats
                            eq_series = result_cap.get('daily_state_valve', pd.DataFrame())
                            w_series = result_cap.get('weights_valve', pd.Series(dtype=float))
                            if isinstance(eq_series, pd.DataFrame) and 'equity' in eq_series.columns:
                                result['metrics'] = perf_stats(eq_series['equity'], w_series)
                                logger.info(f'[{strat}] é‡æ–°è¨ˆç®—ç¸¾æ•ˆæŒ‡æ¨™å®Œæˆ')
                        except Exception as e:
                            logger.warning(f'[{strat}] é‡ç®—ç¸¾æ•ˆæŒ‡æ¨™å¤±æ•—: {e}')

                        
                        # 3) çµ¦ UI ä¸€å€‹æ——æ¨™èˆ‡åƒæ•¸ï¼Œä¾¿æ–¼é¡¯ç¤ºã€Œå·²å¥—ç”¨ã€
                        result['_risk_valve_applied'] = True
                        result['_risk_valve_params'] = {
                            'cap': float(risk_cap),
                            'atr_ratio': float(atr_ratio),
                            'atr20_last': float(atr_20_valid.iloc[-1]) if len(atr_20_valid) > 0 else None,
                            'atr60_last': float(atr_60_valid.iloc[-1]) if len(atr_60_valid) > 0 else None,
                        }
                        
                        true_days = int(mask_aligned.sum())
                        logger.info(f"[{strat}] å…¨å±€é¢¨éšªé–¥é–€å·²å¥—ç”¨ï¼ˆé€æ—¥ï¼‰ï¼Œé¢¨éšªå¤©æ•¸={true_days}, CAP={risk_cap:.2f}")
                    else:
                        logger.warning(f"[{strat}] é¢¨éšªé–¥é–€é‡ç®—æ²’æœ‰è¿”å›çµæœ")
        
        results[strat] = result
    
    # ä½¿ç”¨ç¬¬ä¸€å€‹ç­–ç•¥çš„æ•¸æ“šä½œç‚ºä¸»è¦é¡¯ç¤ºæ•¸æ“š
    first_strat = list(results.keys())[0] if results else strategy_names[0]
    first_smaa_src = param_presets[first_strat].get("smaa_source", "Self")
    df_raw_main, _ = load_data(ticker, start_date, end_date if end_date else None, smaa_source=first_smaa_src)
    
    # çµ±ä¸€ä½¿ç”¨ orient="split" åºåˆ—åŒ–ï¼Œç¢ºä¿ä¸€è‡´æ€§
    payload = {
        'results': results, 


4.

@@ -1215,115 +1215,171 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                atr60 = calculate_atr(df_raw, 60)
                if atr20 is None or atr60 is None:
                    logger.warning(f"[{strat}] ç„¡æ³•è¨ˆç®— ATR20/60ï¼Œè·³éå…¨å±€é¢¨éšªé–¥é–€")
                else:
                    ratio = (atr20 / atr60).replace([np.inf, -np.inf], np.nan)
                    mask = (ratio >= float(atr_ratio))
                    if force_trigger:
                        mask[:] = True  # å¼·åˆ¶å…¨éƒ¨æ—¥å­å¥— CAP

                    # 3) å°é½Šåˆ° ds.indexï¼Œé€æ—¥å£“ w è‡³ CAP
                    mask_aligned = mask.reindex(ds.index).fillna(False).to_numpy()
                    w = ds["w"].astype(float).to_numpy()
                    w_new = w.copy()
                    w_new[mask_aligned] = np.minimum(w_new[mask_aligned], float(risk_cap))
                    ds["w"] = w_new

                    # 4) å›å¯« dsï¼Œä¸¦é‡ç®—äº¤æ˜“/æ¬Šç›Š
                    result["daily_state_std"] = pack_df(ds)

                    # open åƒ¹ï¼ˆæ²’æœ‰ open å°±é€€è€Œæ±‚å…¶æ¬¡ç”¨æ”¶ç›¤åƒ¹ï¼‰
                    open_px = (df_raw["open"] if "open" in df_raw.columns else df_raw.get("æ”¶ç›¤åƒ¹")).astype(float)
                    open_px = open_px.reindex(ds.index).dropna()

                    # è‹¥ä½ æ²¿ç”¨ç¾æœ‰çš„ risk_valve_backtestï¼Œçµ¦ cap_level=1.0 è¡¨ç¤ºã€Œw å·²ç¶“æ˜¯ç›®æ¨™åºåˆ—ã€
                    try:
                        from SSS_EnsembleTab import risk_valve_backtest, CostParams
                        from SSS_EnsembleTab import (
                            risk_valve_backtest,
                            CostParams,
                            _mdd_from_daily_equity,
                            _sell_returns_pct_from_ledger,
                        )
                        
                        # æˆæœ¬åƒæ•¸
                        trade_cost = (strat_params.get("trade_cost", {}) 
                                      if isinstance(strat_params, dict) else {})
                        cost = CostParams(
                            buy_fee_bp=float(trade_cost.get("buy_fee_bp", 4.27)),
                            sell_fee_bp=float(trade_cost.get("sell_fee_bp", 4.27)),
                            sell_tax_bp=float(trade_cost.get("sell_tax_bp", 30.0)),
                        )
                        
                        # åŸºæº–ï¼ˆæœ‰é«˜ä½åƒ¹å°±å¸¶ä¸Šï¼‰
                        bench = pd.DataFrame(index=pd.to_datetime(df_raw.index))
                        if 'close' in df_raw.columns:
                            bench["æ”¶ç›¤åƒ¹"] = pd.to_numeric(df_raw["close"], errors="coerce")
                        elif 'æ”¶ç›¤åƒ¹' in df_raw.columns:
                            bench["æ”¶ç›¤åƒ¹"] = pd.to_numeric(df_raw["æ”¶ç›¤åƒ¹"], errors="coerce")
                        if 'high' in df_raw.columns and 'low' in df_raw.columns:
                            bench["æœ€é«˜åƒ¹"] = pd.to_numeric(df_raw["high"], errors="coerce")
                            bench["æœ€ä½åƒ¹"] = pd.to_numeric(df_raw["low"], errors="coerce")
                        elif 'æœ€é«˜åƒ¹' in df_raw.columns and 'æœ€ä½åƒ¹' in df_raw.columns:
                            bench["æœ€é«˜åƒ¹"] = pd.to_numeric(df_raw["æœ€é«˜åƒ¹"], errors="coerce")
                            bench["æœ€ä½åƒ¹"] = pd.to_numeric(df_raw["æœ€ä½åƒ¹"], errors="coerce")
                        
                        result_cap = risk_valve_backtest(
                            open_px=open_px,
                            w=ds["w"].astype(float).reindex(open_px.index).fillna(0.0),
                            cost=cost,
                            benchmark_df=bench,
                            mode="cap",
                            cap_level=1.0,
                        )
                    except Exception as e:
                        logger.warning(f"[{strat}] ç„¡æ³•å°å…¥ risk_valve_backtest: {e}")
                        result_cap = None

                    if result_cap:
                        # === å®‰å…¨è¦†å¯«ï¼šæ¸…æ‰èˆŠéµä¸¦è£œé½Šæ–°éµ ===
                        logger.info(f"[UI_CHECK] å³å°‡è¦†å¯«ï¼šnew_trades={len(result_cap.get('trade_ledger_valve', pd.DataFrame()))} rows, new_ds={len(result_cap.get('daily_state_valve', pd.DataFrame()))} rows")
                        
                        # 1) è¦†å¯«çµæœ â€”â€” ä¸€å¾‹ç”¨ pack_df/pack_series
                        if 'trade_ledger_valve' in result_cap:
                            result['trades'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger_std'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_df'] = pack_df(result_cap['trade_ledger_valve'])
                        
                        if 'daily_state_valve' in result_cap:
                            result['daily_state'] = pack_df(result_cap['daily_state_valve'])
                            result['daily_state_std'] = pack_df(result_cap['daily_state_valve'])
                        
                        if 'weights_valve' in result_cap:
                            result['weight_curve'] = pack_series(result_cap['weights_valve'])
                        
                        # æ¬Šç›Šæ›²ç·šï¼šè‹¥æ˜¯ Series
                        if 'daily_state_valve' in result_cap and 'equity' in result_cap['daily_state_valve']:
                            try:
                                result['equity_curve'] = pack_series(result_cap['daily_state_valve']['equity'])
                            except Exception:
                                # è‹¥ä½ å­˜çš„æ˜¯ DataFrame
                                result['equity_curve'] = pack_df(result_cap['daily_state_valve']['equity'].to_frame('equity'))
                        
                        # 2) **é—œéµ**ï¼šæŠŠ UI å¯èƒ½æ‹¿ä¾†ç”¨çš„èˆŠå¿«å–æ¸…æ‰ï¼Œå¼·è¿« UI èµ°æ–°è³‡æ–™
                        for k in ['trades_ui', 'trade_df', 'trade_ledger_std', 'metrics']:
                            if k in result:
                                result.pop(k, None)

                        # 2025-08-20 é‡ç®—æŒ‡æ¨™ä»¥ä¿ç•™ç¸¾æ•ˆè³‡è¨Š #app_dash.py
                        ledger_valve = result_cap.get('trade_ledger_valve', pd.DataFrame())
                        ds_valve = result_cap.get('daily_state_valve', pd.DataFrame())
                        if not ledger_valve.empty and not ds_valve.empty and 'equity' in ds_valve:
                            r = _sell_returns_pct_from_ledger(ledger_valve)
                            eq = ds_valve['equity']
                            total_ret = eq.iloc[-1] / eq.iloc[0] - 1
                            years = max((eq.index[-1] - eq.index[0]).days / 365.25, 1)
                            ann_ret = (1 + total_ret) ** (1 / years) - 1
                            mdd = _mdd_from_daily_equity(eq)
                            dd = eq / eq.cummax() - 1
                            blocks = (~(dd < 0)).cumsum()
                            dd_dur = int((dd.groupby(blocks).cumcount() + 1).where(dd < 0).max() or 0)
                            num_trades = len(r)
                            win_rate = (r > 0).sum() / num_trades if num_trades > 0 else 0
                            avg_win = r[r > 0].mean() if win_rate > 0 else np.nan
                            avg_loss = r[r < 0].mean() if win_rate < 1 else np.nan
                            payoff = abs(avg_win / avg_loss) if avg_loss != 0 and not np.isnan(avg_win) else np.nan
                            daily_r = eq.pct_change().dropna()
                            sharpe = (daily_r.mean() * np.sqrt(252)) / daily_r.std() if daily_r.std() != 0 else np.nan
                            downside = daily_r[daily_r < 0]
                            sortino = (daily_r.mean() * np.sqrt(252)) / downside.std() if downside.std() != 0 else np.nan
                            ann_vol = daily_r.std() * np.sqrt(252) if len(daily_r) > 0 else np.nan
                            prof = r[r > 0].sum()
                            loss = abs(r[r < 0].sum())
                            pf = prof / loss if loss != 0 else np.nan
                            win_flag = r > 0
                            grp = (win_flag != win_flag.shift()).cumsum()
                            consec = win_flag.groupby(grp).cumcount() + 1
                            max_wins = int(consec[win_flag].max() if True in win_flag.values else 0)
                            max_losses = int(consec[~win_flag].max() if False in win_flag.values else 0)
                            result['metrics'] = {
                                'total_return': float(total_ret),
                                'annual_return': float(ann_ret),
                                'max_drawdown': float(mdd),
                                'max_drawdown_duration': dd_dur,
                                'calmar_ratio': float(ann_ret / abs(mdd)) if mdd < 0 else np.nan,
                                'num_trades': int(num_trades),
                                'win_rate': float(win_rate),
                                'avg_win': float(avg_win) if not np.isnan(avg_win) else np.nan,
                                'avg_loss': float(avg_loss) if not np.isnan(avg_loss) else np.nan,
                                'payoff_ratio': float(payoff) if not np.isnan(payoff) else np.nan,
                                'sharpe_ratio': float(sharpe) if not np.isnan(sharpe) else np.nan,
                                'sortino_ratio': float(sortino) if not np.isnan(sortino) else np.nan,
                                'max_consecutive_wins': max_wins,
                                'max_consecutive_losses': max_losses,
                                'annualized_volatility': float(ann_vol) if not np.isnan(ann_vol) else np.nan,
                                'profit_factor': float(pf) if not np.isnan(pf) else np.nan,
                            }
                        
                        # 3) çµ¦ UI ä¸€å€‹æ——æ¨™èˆ‡åƒæ•¸ï¼Œä¾¿æ–¼é¡¯ç¤ºã€Œå·²å¥—ç”¨ã€
                        result['_risk_valve_applied'] = True
                        result['_risk_valve_params'] = {
                            'cap': float(risk_cap),
                            'atr_ratio': float(atr_ratio),
                            'atr20_last': float(atr_20_valid.iloc[-1]) if len(atr_20_valid) > 0 else None,
                            'atr60_last': float(atr_60_valid.iloc[-1]) if len(atr_60_valid) > 0 else None,
                        }
                        
                        true_days = int(mask_aligned.sum())
                        logger.info(f"[{strat}] å…¨å±€é¢¨éšªé–¥é–€å·²å¥—ç”¨ï¼ˆé€æ—¥ï¼‰ï¼Œé¢¨éšªå¤©æ•¸={true_days}, CAP={risk_cap:.2f}")
                    else:
                        logger.warning(f"[{strat}] é¢¨éšªé–¥é–€é‡ç®—æ²’æœ‰è¿”å›çµæœ")
        
        results[strat] = result
    
    # ä½¿ç”¨ç¬¬ä¸€å€‹ç­–ç•¥çš„æ•¸æ“šä½œç‚ºä¸»è¦é¡¯ç¤ºæ•¸æ“š
    first_strat = list(results.keys())[0] if results else strategy_names[0]
    first_smaa_src = param_presets[first_strat].get("smaa_source", "Self")
    df_raw_main, _ = load_data(ticker, start_date, end_date if end_date else None, smaa_source=first_smaa_src)
    
    # çµ±ä¸€ä½¿ç”¨ orient="split" åºåˆ—åŒ–ï¼Œç¢ºä¿ä¸€è‡´æ€§
    payload = {
        'results': results, 
