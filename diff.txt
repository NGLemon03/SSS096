1.

@@ -186,51 +186,53 @@ def series_from_pack(data):
        return pd.Series(dtype=float)
    
    # 如果是字串，進行額外檢查
    if isinstance(data, str):
        if data == "" or data == "[]":
            return pd.Series(dtype=float)
        # Series 也先試 split
        for orient in ("split", None):
            try:
                kw = {"orient": orient} if orient else {}
                return pd.read_json(io.StringIO(data), typ="series", **kw)
            except Exception:
                pass
        return pd.Series(dtype=float)
    
    if isinstance(data, (list, dict)):
        try:
            return pd.Series(data)
        except Exception:
            return pd.Series(dtype=float)
    
    return pd.Series(dtype=float)

from SSSv096 import (
    param_presets, load_data, compute_single, compute_dual, compute_RMA,
    compute_ssma_turn_combined, backtest_unified, plot_stock_price, plot_equity_cash, plot_weight_series, calculate_holding_periods
    compute_ssma_turn_combined, backtest_unified, plot_stock_price,
    plot_equity_cash, plot_weight_series, calculate_holding_periods,
    calculate_metrics
)

# 彈性匯入 pack_df/pack_series 函數
try:
    from sss_core.schemas import pack_df, pack_series
except Exception:
    from schemas import pack_df, pack_series

# 匯入權重欄位確保函式
try:
    from sss_core.normalize import _ensure_weight_columns
except Exception:
    # 如果無法匯入，定義一個空的函式作為 fallback
    def _ensure_weight_columns(df):
        return df

# 假設你有 get_version_history_html
try:
    from version_history import get_version_history_html
except ImportError:
    def get_version_history_html() -> str:
        return "<b>無法載入版本歷史記錄</b>"

# --- 保證放進 Store 的都是 JSON-safe ---
def _pack_any(x):
@@ -1215,51 +1217,56 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                atr60 = calculate_atr(df_raw, 60)
                if atr20 is None or atr60 is None:
                    logger.warning(f"[{strat}] 無法計算 ATR20/60，跳過全局風險閥門")
                else:
                    ratio = (atr20 / atr60).replace([np.inf, -np.inf], np.nan)
                    mask = (ratio >= float(atr_ratio))
                    if force_trigger:
                        mask[:] = True  # 強制全部日子套 CAP

                    # 3) 對齊到 ds.index，逐日壓 w 至 CAP
                    mask_aligned = mask.reindex(ds.index).fillna(False).to_numpy()
                    w = ds["w"].astype(float).to_numpy()
                    w_new = w.copy()
                    w_new[mask_aligned] = np.minimum(w_new[mask_aligned], float(risk_cap))
                    ds["w"] = w_new

                    # 4) 回寫 ds，並重算交易/權益
                    result["daily_state_std"] = pack_df(ds)

                    # open 價（沒有 open 就退而求其次用收盤價）
                    open_px = (df_raw["open"] if "open" in df_raw.columns else df_raw.get("收盤價")).astype(float)
                    open_px = open_px.reindex(ds.index).dropna()

                    # 若你沿用現有的 risk_valve_backtest，給 cap_level=1.0 表示「w 已經是目標序列」
                    try:
                        from SSS_EnsembleTab import risk_valve_backtest, CostParams
                        from SSS_EnsembleTab import (
                            risk_valve_backtest,
                            CostParams,
                            build_trade_snapshots_from_ledger,
                            _sell_returns_pct_from_ledger,
                        )
                        
                        # 成本參數
                        trade_cost = (strat_params.get("trade_cost", {}) 
                                      if isinstance(strat_params, dict) else {})
                        cost = CostParams(
                            buy_fee_bp=float(trade_cost.get("buy_fee_bp", 4.27)),
                            sell_fee_bp=float(trade_cost.get("sell_fee_bp", 4.27)),
                            sell_tax_bp=float(trade_cost.get("sell_tax_bp", 30.0)),
                        )
                        
                        # 基準（有高低價就帶上）
                        bench = pd.DataFrame(index=pd.to_datetime(df_raw.index))
                        if 'close' in df_raw.columns:
                            bench["收盤價"] = pd.to_numeric(df_raw["close"], errors="coerce")
                        elif '收盤價' in df_raw.columns:
                            bench["收盤價"] = pd.to_numeric(df_raw["收盤價"], errors="coerce")
                        if 'high' in df_raw.columns and 'low' in df_raw.columns:
                            bench["最高價"] = pd.to_numeric(df_raw["high"], errors="coerce")
                            bench["最低價"] = pd.to_numeric(df_raw["low"], errors="coerce")
                        elif '最高價' in df_raw.columns and '最低價' in df_raw.columns:
                            bench["最高價"] = pd.to_numeric(df_raw["最高價"], errors="coerce")
                            bench["最低價"] = pd.to_numeric(df_raw["最低價"], errors="coerce")
                        
                        result_cap = risk_valve_backtest(
                            open_px=open_px,
@@ -1275,56 +1282,72 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo

                    if result_cap:
                        # === 安全覆寫：清掉舊鍵並補齊新鍵 ===
                        logger.info(f"[UI_CHECK] 即將覆寫：new_trades={len(result_cap.get('trade_ledger_valve', pd.DataFrame()))} rows, new_ds={len(result_cap.get('daily_state_valve', pd.DataFrame()))} rows")
                        
                        # 1) 覆寫結果 —— 一律用 pack_df/pack_series
                        if 'trade_ledger_valve' in result_cap:
                            result['trades'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger_std'] = pack_df(result_cap['trade_ledger_valve'])
                        
                        if 'daily_state_valve' in result_cap:
                            result['daily_state'] = pack_df(result_cap['daily_state_valve'])
                            result['daily_state_std'] = pack_df(result_cap['daily_state_valve'])
                        
                        if 'weights_valve' in result_cap:
                            result['weight_curve'] = pack_series(result_cap['weights_valve'])
                        
                        # 權益曲線：若是 Series
                        if 'daily_state_valve' in result_cap and 'equity' in result_cap['daily_state_valve']:
                            try:
                                result['equity_curve'] = pack_series(result_cap['daily_state_valve']['equity'])
                            except Exception:
                                # 若你存的是 DataFrame
                                result['equity_curve'] = pack_df(result_cap['daily_state_valve']['equity'].to_frame('equity'))
                        

                        # 2) **關鍵**：把 UI 可能拿來用的舊快取清掉，強迫 UI 走新資料
                        for k in ['trades_ui', 'trade_df', 'trade_ledger_std', 'metrics']:
                            if k in result:
                                result.pop(k, None)
                        

                        # 2025-08-19 修復：風險閥門套用後重建交易資料與績效指標 #app_dash.py
                        if 'trade_ledger_valve' in result_cap and 'daily_state_valve' in result_cap:
                            try:
                                trade_df_valve = build_trade_snapshots_from_ledger(result_cap['trade_ledger_valve'])
                                result['trade_df'] = pack_df(trade_df_valve)
                                sell_ret = _sell_returns_pct_from_ledger(result_cap['trade_ledger_valve']) / 100.0
                                trades_list = [(d, r, d) for d, r in sell_ret.items()]
                                equity_valve = result_cap['daily_state_valve']['equity']
                                idx_df = pd.DataFrame(index=equity_valve.index)
                                result['metrics'] = calculate_metrics(trades_list, idx_df, equity_valve)
                            except Exception as e:
                                logger.warning(f"[{strat}] 風險閥門績效重算失敗: {e}")
                                result['metrics'] = {}
                        else:
                            result['metrics'] = {}

                        # 3) 給 UI 一個旗標與參數，便於顯示「已套用」
                        result['_risk_valve_applied'] = True
                        result['_risk_valve_params'] = {
                            'cap': float(risk_cap),
                            'atr_ratio': float(atr_ratio),
                            'atr20_last': float(atr_20_valid.iloc[-1]) if len(atr_20_valid) > 0 else None,
                            'atr60_last': float(atr_60_valid.iloc[-1]) if len(atr_60_valid) > 0 else None,
                        }
                        
                        true_days = int(mask_aligned.sum())
                        logger.info(f"[{strat}] 全局風險閥門已套用（逐日），風險天數={true_days}, CAP={risk_cap:.2f}")
                    else:
                        logger.warning(f"[{strat}] 風險閥門重算沒有返回結果")
        
        results[strat] = result
    
    # 使用第一個策略的數據作為主要顯示數據
    first_strat = list(results.keys())[0] if results else strategy_names[0]
    first_smaa_src = param_presets[first_strat].get("smaa_source", "Self")
    df_raw_main, _ = load_data(ticker, start_date, end_date if end_date else None, smaa_source=first_smaa_src)
    
    # 統一使用 orient="split" 序列化，確保一致性
    payload = {
        'results': results, 
        'df_raw': df_raw_main.to_json(date_format='iso', orient='split'), 

2.
import dash
from dash import dcc, html, dash_table, Input, Output, State, ctx, no_update
import dash_bootstrap_components as dbc
import pandas as pd
import plotly.graph_objects as go
import json
import io
from dash.dependencies import ALL
import shutil
import os
from datetime import datetime, timedelta
from pathlib import Path
import joblib
from analysis import config as cfg
import yfinance as yf
import logging
import numpy as np
from urllib.parse import quote as urlparse

#app_dash.py
# 修改紀錄:
# 2025-08-19: 修正風險閥門套用後績效指標遺失問題，並在結果構建後加入閥門資訊

# 配置 logger - 使用新的顯式初始化
from analysis.logging_config import init_logging
import os

# 強制啟用檔案日誌，不依賴環境變數
os.environ["SSS_CREATE_LOGS"] = "1"

# 直接呼叫 init_logging，它會使用正確的日誌目錄
init_logging(enable_file=True)
logger = logging.getLogger("SSS.App")

# 設定為 DEBUG 級別，詳細調試資訊會寫入日誌檔案
logger.setLevel(logging.DEBUG)
logger.info("已啟用詳細調試模式 - 調試資訊將寫入日誌檔案")
logger.info(f"日誌目錄: {os.path.abspath('analysis/log')}")

# ATR 計算函數
def calculate_atr(df, window):
    """計算 ATR (Average True Range)"""
    try:
        # 支援多種欄位名稱格式
        high_col = None
        low_col = None
        close_col = None
        
@@ -868,98 +872,99 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
            result = backtest_unified(df_ind, strat_type, backtest_params, buy_dates, sell_dates, discount=discount, trade_cooldown_bars=cooldown, bad_holding=bad_holding)
            
            # === 在 ssma_turn 也套用風險閥門（和 Ensemble 一致的後置覆寫） ===
            if global_apply:
                # 判斷是否要觸發（與你的 ATR 檢查或強制觸發一致）
                valve_triggered_local = False
                ratio_local = None
                try:
                    atr_20 = calculate_atr(df_raw, 20)
                    atr_60 = calculate_atr(df_raw, 60)
                    if not atr_20.empty and not atr_60.empty:
                        a20 = atr_20.dropna().iloc[-1]
                        a60 = atr_60.dropna().iloc[-1]
                        if a60 > 0:
                            ratio_local = float(a20 / a60)
                            valve_triggered_local = (ratio_local >= atr_ratio)  # 建議使用 >=
                except Exception:
                    pass

                if force_trigger:
                    valve_triggered_local = True
                    if ratio_local is None:
                        ratio_local = 1.5

                if valve_triggered_local:
                    from SSS_EnsembleTab import risk_valve_backtest, CostParams
                    from SSS_EnsembleTab import risk_valve_backtest, CostParams, perf_stats
                    # 取得 open 價；df_raw 欄位名稱是小寫
                    open_px = df_raw['open'] if 'open' in df_raw.columns else df_raw['close']
                    # 從回測輸出抓 w（先用標準化 daily_state，如果沒有就用原 daily_state）
                    w_series = None
                    try:
                        ds_std = df_from_pack(result.get('daily_state_std'))
                        if ds_std is not None and not ds_std.empty and 'w' in ds_std.columns:
                            w_series = ds_std['w']
                    except Exception:
                        pass
                    if w_series is None:
                        ds = df_from_pack(result.get('daily_state'))
                        if ds is not None and not ds.empty and 'w' in ds.columns:
                            w_series = ds['w']

                    if w_series is not None:
                        # 交易成本（與 Ensemble 分支一致）
                        trade_cost = strat_params.get('trade_cost', {})
                        cost_params = CostParams(
                            buy_fee_bp=float(trade_cost.get("buy_fee_bp", 4.27)),
                            sell_fee_bp=float(trade_cost.get("sell_fee_bp", 4.27)),
                            sell_tax_bp=float(trade_cost.get("sell_tax_bp", 30.0))
                        )

                        rv = risk_valve_backtest(
                            open_px=open_px,
                            w=w_series,
                            cost=cost_params,
                            benchmark_df=df_raw,
                            mode="cap",
                            cap_level=float(risk_cap),
                        )

                        # 覆寫結果，確保 UI 與輸出一致（和 Ensemble 分支對齊）
                        result['equity_curve']     = pack_series(rv["daily_state_valve"]["equity"])
                        result['daily_state']      = pack_df(rv["daily_state_valve"])
                        result['daily_state_std']  = pack_df(rv["daily_state_valve"])
                        result['trade_ledger']     = pack_df(rv["trade_ledger_valve"])
                        result['trade_ledger_std'] = pack_df(rv["trade_ledger_valve"])
                        result['weight_curve']     = pack_series(rv["weights_valve"])
                        result['metrics']          = perf_stats(rv["daily_state_valve"]["equity"], rv["weights_valve"])
                        # 給 UI 的標記（下個小節會用到）
                        result['valve'] = {
                            "applied": True,
                            "cap": float(risk_cap),
                            "atr_ratio": ratio_local
                        }
                        

                        logger.info(f"[{strat}] SSMA 風險閥門已套用（cap={risk_cap}, ratio={ratio_local:.4f}）")
                    else:
                        logger.warning(f"[{strat}] SSMA 無法取得權重序列，跳過風險閥門套用")
                else:
                    logger.info(f"[{strat}] SSMA 風險閥門未觸發，使用原始結果")
                    # 給 UI 的標記（未觸發）
                    result['valve'] = {
                        "applied": False,
                        "cap": float(risk_cap),
                        "atr_ratio": ratio_local if ratio_local is not None else "N/A"
                    }
        elif strat_type == 'ensemble':
            # 使用新的 ensemble_runner 避免循環依賴
            try:
                from runners.ensemble_runner import run_ensemble_backtest
                from SSS_EnsembleTab import EnsembleParams, CostParams, RunConfig
                
                # 把 SSSv096 的巢狀參數攤平
                flat_params = {}
                flat_params.update(strat_params.get('params', {}))
                flat_params.update(strat_params.get('trade_cost', {}))
                flat_params['method'] = strat_params.get('method', 'majority')
                flat_params['ticker'] = ticker
                
                # 使用比例門檻避免 N 變動時失真
@@ -1048,117 +1053,118 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                                if valve_triggered:
                                    logger.info(f"[{strat}] 🔴 風險閥門觸發！ATR比值({ratio:.4f}) > 門檻({atr_ratio})")
                                else:
                                    logger.info(f"[{strat}] 🟢 風險閥門未觸發，ATR比值({ratio:.4f}) <= 門檻({atr_ratio})")
                            else:
                                logger.warning(f"[{strat}] Ensemble ATR(60) 值為 0，無法計算比值")
                        else:
                            logger.warning(f"[{strat}] Ensemble ATR 數據不足")
                    else:
                        logger.warning(f"[{strat}] Ensemble ATR 計算結果為空")
                        
                except Exception as e:
                    logger.warning(f"[{strat}] 無法計算 Ensemble ATR 比值: {e}")
                    logger.warning(f"[{strat}] 錯誤詳情: {type(e).__name__}: {str(e)}")

                # 如果啟用強制觸發，則強制觸發風險閥門
                if force_trigger:
                    valve_triggered = True
                    logger.info(f"[{strat}] 🔴 強制觸發風險閥門啟用")
                    if ratio is None:
                        ratio = 1.5  # 設定一個預設值用於顯示

                # 使用新的 ensemble_runner 執行
                backtest_result = run_ensemble_backtest(cfg)

                valve_info = None
                # 若全局開關開啟且達觸發條件，才在權重序列上套用 CAP
                if global_apply and valve_triggered:
                    from SSS_EnsembleTab import risk_valve_backtest
                    from SSS_EnsembleTab import risk_valve_backtest, perf_stats
                    bench = df_raw  # 已含 open/high/low/close/volume
                    

                    logger.info(f"[{strat}] 🔴 開始套用風險閥門: cap={risk_cap}, ratio={ratio:.4f}")
                    

                    rv = risk_valve_backtest(
                        open_px=backtest_result.price_series,
                        w=backtest_result.weight_curve,
                        cost=cost_params,
                        benchmark_df=bench,
                        mode="cap",
                        cap_level=float(risk_cap),
                    )
                    # 覆寫結果，確保 UI 與輸出一致
                    backtest_result.daily_state = rv["daily_state_valve"]
                    backtest_result.ledger = rv["trade_ledger_valve"]
                    backtest_result.weight_curve = rv["weights_valve"]
                    backtest_result.equity_curve = rv["daily_state_valve"]["equity"]
                    backtest_result.stats = perf_stats(backtest_result.equity_curve, backtest_result.weight_curve)
                    logger.info(f"[{strat}] 風險閥門已套用（cap={risk_cap}, ratio={ratio:.4f}）")
                    

                    # 增加風險閥門效果的詳細資訊
                    if "metrics" in rv:
                        logger.info(f"[{strat}] 風險閥門效果: PF原始={rv['metrics'].get('pf_orig', 'N/A'):.2f}, PF閥門={rv['metrics'].get('pf_valve', 'N/A'):.2f}")
                        logger.info(f"[{strat}] 風險閥門效果: MDD原始={rv['metrics'].get('mdd_orig', 'N/A'):.2f}%, MDD閥門={rv['metrics'].get('mdd_valve', 'N/A'):.2f}%")
                    
                    # 給 UI 的標記（與 SSMA 分支對齊）
                    result['valve'] = {

                    valve_info = {
                        "applied": True,
                        "cap": float(risk_cap),
                        "atr_ratio": ratio
                        "atr_ratio": ratio,
                    }
                else:
                    if global_apply:
                        logger.info(f"[{strat}] 🟢 風險閥門未觸發，使用原始參數")
                        # 給 UI 的標記（未觸發）
                        result['valve'] = {
                        valve_info = {
                            "applied": False,
                            "cap": float(risk_cap),
                            "atr_ratio": ratio if ratio is not None else "N/A"
                            "atr_ratio": ratio if ratio is not None else "N/A",
                        }
                    else:
                        logger.info(f"[{strat}] ⚪ 全局風險閥門未啟用")
                        # 給 UI 的標記（未啟用）
                        result['valve'] = {
                        valve_info = {
                            "applied": False,
                            "cap": "N/A",
                            "atr_ratio": "N/A"
                            "atr_ratio": "N/A",
                        }
                

                # 轉換為舊格式以保持相容性
                result = {
                    'trades': [],
                    'trade_df': pack_df(backtest_result.trades),
                    'trades_df': pack_df(backtest_result.trades),
                    'signals_df': pack_df(backtest_result.trades[['trade_date', 'type', 'price']].rename(columns={'type': 'action'}) if not backtest_result.trades.empty else pd.DataFrame(columns=['trade_date', 'action', 'price'])),
                    'metrics': backtest_result.stats,
                    'equity_curve': pack_series(backtest_result.equity_curve),
                    'cash_curve': pack_series(backtest_result.cash_curve) if backtest_result.cash_curve is not None else "",
                    'weight_curve': pack_series(backtest_result.weight_curve) if backtest_result.weight_curve is not None else pack_series(pd.Series(0.0, index=backtest_result.equity_curve.index)),
                    'price_series': pack_series(backtest_result.price_series) if backtest_result.price_series is not None else pack_series(pd.Series(1.0, index=backtest_result.equity_curve.index)),
                    'daily_state': pack_df(backtest_result.daily_state),
                    'trade_ledger': pack_df(backtest_result.ledger),
                    'daily_state_std': pack_df(backtest_result.daily_state),
                    'trade_ledger_std': pack_df(backtest_result.ledger)
                }
                if valve_info is not None:
                    result['valve'] = valve_info
                
                logger.info(f"[Ensemble] 執行成功: 權益曲線長度={len(backtest_result.equity_curve)}, 交易數={len(backtest_result.ledger) if backtest_result.ledger is not None and not backtest_result.ledger.empty else 0}")
                
            except Exception as e:
                logger.error(f"Ensemble 策略執行失敗: {e}")
                # 創建空的結果
                result = {
                    'trades': [],
                    'trade_df': pd.DataFrame(),
                    'trades_df': pd.DataFrame(),
                    'signals_df': pd.DataFrame(),
                    'metrics': {'total_return': 0.0, 'annual_return': 0.0, 'max_drawdown': 0.0, 'sharpe_ratio': 0.0, 'calmar_ratio': 0.0, 'num_trades': 0},
                    'equity_curve': pd.Series(1.0, index=df_raw.index)
                }
            
            # === 修復 3：添加調試日誌，核對子策略集合是否一致 ===
            logger.info(f"[Ensemble] 執行完成，ticker={ticker}, method={flat_params.get('method')}")
            if 'equity_curve' in result and hasattr(result['equity_curve'], 'shape'):
                logger.info(f"[Ensemble] 權益曲線長度: {len(result['equity_curve'])}")
            if 'trade_df' in result and hasattr(result['trade_df'], 'shape'):
                logger.info(f"[Ensemble] 交易記錄數量: {len(result['trade_df'])}")
        else:
            if strat_type == 'single':
                df_ind = compute_single(df_raw, df_factor, strat_params["linlen"], strat_params["factor"], strat_params["smaalen"], strat_params["devwin"], smaa_source=smaa_src)
            elif strat_type == 'dual':
3.
@@ -1280,50 +1280,61 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                        # 1) 覆寫結果 —— 一律用 pack_df/pack_series
                        if 'trade_ledger_valve' in result_cap:
                            result['trades'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger_std'] = pack_df(result_cap['trade_ledger_valve'])
                        
                        if 'daily_state_valve' in result_cap:
                            result['daily_state'] = pack_df(result_cap['daily_state_valve'])
                            result['daily_state_std'] = pack_df(result_cap['daily_state_valve'])
                        
                        if 'weights_valve' in result_cap:
                            result['weight_curve'] = pack_series(result_cap['weights_valve'])
                        
                        # 權益曲線：若是 Series
                        if 'daily_state_valve' in result_cap and 'equity' in result_cap['daily_state_valve']:
                            try:
                                result['equity_curve'] = pack_series(result_cap['daily_state_valve']['equity'])
                            except Exception:
                                # 若你存的是 DataFrame
                                result['equity_curve'] = pack_df(result_cap['daily_state_valve']['equity'].to_frame('equity'))
                        
                        # 2) **關鍵**：把 UI 可能拿來用的舊快取清掉，強迫 UI 走新資料
                        for k in ['trades_ui', 'trade_df', 'trade_ledger_std', 'metrics']:
                            if k in result:
                                result.pop(k, None)
                        # 2025-08-20 修復：重算績效指標避免清空後僅剩平均持倉天數
                        try:
                            from SSS_EnsembleTab import perf_stats
                            eq_series = result_cap.get('daily_state_valve', pd.DataFrame())
                            w_series = result_cap.get('weights_valve', pd.Series(dtype=float))
                            if isinstance(eq_series, pd.DataFrame) and 'equity' in eq_series.columns:
                                result['metrics'] = perf_stats(eq_series['equity'], w_series)
                                logger.info(f'[{strat}] 重新計算績效指標完成')
                        except Exception as e:
                            logger.warning(f'[{strat}] 重算績效指標失敗: {e}')

                        
                        # 3) 給 UI 一個旗標與參數，便於顯示「已套用」
                        result['_risk_valve_applied'] = True
                        result['_risk_valve_params'] = {
                            'cap': float(risk_cap),
                            'atr_ratio': float(atr_ratio),
                            'atr20_last': float(atr_20_valid.iloc[-1]) if len(atr_20_valid) > 0 else None,
                            'atr60_last': float(atr_60_valid.iloc[-1]) if len(atr_60_valid) > 0 else None,
                        }
                        
                        true_days = int(mask_aligned.sum())
                        logger.info(f"[{strat}] 全局風險閥門已套用（逐日），風險天數={true_days}, CAP={risk_cap:.2f}")
                    else:
                        logger.warning(f"[{strat}] 風險閥門重算沒有返回結果")
        
        results[strat] = result
    
    # 使用第一個策略的數據作為主要顯示數據
    first_strat = list(results.keys())[0] if results else strategy_names[0]
    first_smaa_src = param_presets[first_strat].get("smaa_source", "Self")
    df_raw_main, _ = load_data(ticker, start_date, end_date if end_date else None, smaa_source=first_smaa_src)
    
    # 統一使用 orient="split" 序列化，確保一致性
    payload = {
        'results': results, 


4.

@@ -1215,115 +1215,171 @@ def run_backtest(n_clicks, auto_run, ticker, start_date, end_date, discount, coo
                atr60 = calculate_atr(df_raw, 60)
                if atr20 is None or atr60 is None:
                    logger.warning(f"[{strat}] 無法計算 ATR20/60，跳過全局風險閥門")
                else:
                    ratio = (atr20 / atr60).replace([np.inf, -np.inf], np.nan)
                    mask = (ratio >= float(atr_ratio))
                    if force_trigger:
                        mask[:] = True  # 強制全部日子套 CAP

                    # 3) 對齊到 ds.index，逐日壓 w 至 CAP
                    mask_aligned = mask.reindex(ds.index).fillna(False).to_numpy()
                    w = ds["w"].astype(float).to_numpy()
                    w_new = w.copy()
                    w_new[mask_aligned] = np.minimum(w_new[mask_aligned], float(risk_cap))
                    ds["w"] = w_new

                    # 4) 回寫 ds，並重算交易/權益
                    result["daily_state_std"] = pack_df(ds)

                    # open 價（沒有 open 就退而求其次用收盤價）
                    open_px = (df_raw["open"] if "open" in df_raw.columns else df_raw.get("收盤價")).astype(float)
                    open_px = open_px.reindex(ds.index).dropna()

                    # 若你沿用現有的 risk_valve_backtest，給 cap_level=1.0 表示「w 已經是目標序列」
                    try:
                        from SSS_EnsembleTab import risk_valve_backtest, CostParams
                        from SSS_EnsembleTab import (
                            risk_valve_backtest,
                            CostParams,
                            _mdd_from_daily_equity,
                            _sell_returns_pct_from_ledger,
                        )
                        
                        # 成本參數
                        trade_cost = (strat_params.get("trade_cost", {}) 
                                      if isinstance(strat_params, dict) else {})
                        cost = CostParams(
                            buy_fee_bp=float(trade_cost.get("buy_fee_bp", 4.27)),
                            sell_fee_bp=float(trade_cost.get("sell_fee_bp", 4.27)),
                            sell_tax_bp=float(trade_cost.get("sell_tax_bp", 30.0)),
                        )
                        
                        # 基準（有高低價就帶上）
                        bench = pd.DataFrame(index=pd.to_datetime(df_raw.index))
                        if 'close' in df_raw.columns:
                            bench["收盤價"] = pd.to_numeric(df_raw["close"], errors="coerce")
                        elif '收盤價' in df_raw.columns:
                            bench["收盤價"] = pd.to_numeric(df_raw["收盤價"], errors="coerce")
                        if 'high' in df_raw.columns and 'low' in df_raw.columns:
                            bench["最高價"] = pd.to_numeric(df_raw["high"], errors="coerce")
                            bench["最低價"] = pd.to_numeric(df_raw["low"], errors="coerce")
                        elif '最高價' in df_raw.columns and '最低價' in df_raw.columns:
                            bench["最高價"] = pd.to_numeric(df_raw["最高價"], errors="coerce")
                            bench["最低價"] = pd.to_numeric(df_raw["最低價"], errors="coerce")
                        
                        result_cap = risk_valve_backtest(
                            open_px=open_px,
                            w=ds["w"].astype(float).reindex(open_px.index).fillna(0.0),
                            cost=cost,
                            benchmark_df=bench,
                            mode="cap",
                            cap_level=1.0,
                        )
                    except Exception as e:
                        logger.warning(f"[{strat}] 無法導入 risk_valve_backtest: {e}")
                        result_cap = None

                    if result_cap:
                        # === 安全覆寫：清掉舊鍵並補齊新鍵 ===
                        logger.info(f"[UI_CHECK] 即將覆寫：new_trades={len(result_cap.get('trade_ledger_valve', pd.DataFrame()))} rows, new_ds={len(result_cap.get('daily_state_valve', pd.DataFrame()))} rows")
                        
                        # 1) 覆寫結果 —— 一律用 pack_df/pack_series
                        if 'trade_ledger_valve' in result_cap:
                            result['trades'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_ledger_std'] = pack_df(result_cap['trade_ledger_valve'])
                            result['trade_df'] = pack_df(result_cap['trade_ledger_valve'])
                        
                        if 'daily_state_valve' in result_cap:
                            result['daily_state'] = pack_df(result_cap['daily_state_valve'])
                            result['daily_state_std'] = pack_df(result_cap['daily_state_valve'])
                        
                        if 'weights_valve' in result_cap:
                            result['weight_curve'] = pack_series(result_cap['weights_valve'])
                        
                        # 權益曲線：若是 Series
                        if 'daily_state_valve' in result_cap and 'equity' in result_cap['daily_state_valve']:
                            try:
                                result['equity_curve'] = pack_series(result_cap['daily_state_valve']['equity'])
                            except Exception:
                                # 若你存的是 DataFrame
                                result['equity_curve'] = pack_df(result_cap['daily_state_valve']['equity'].to_frame('equity'))
                        
                        # 2) **關鍵**：把 UI 可能拿來用的舊快取清掉，強迫 UI 走新資料
                        for k in ['trades_ui', 'trade_df', 'trade_ledger_std', 'metrics']:
                            if k in result:
                                result.pop(k, None)

                        # 2025-08-20 重算指標以保留績效資訊 #app_dash.py
                        ledger_valve = result_cap.get('trade_ledger_valve', pd.DataFrame())
                        ds_valve = result_cap.get('daily_state_valve', pd.DataFrame())
                        if not ledger_valve.empty and not ds_valve.empty and 'equity' in ds_valve:
                            r = _sell_returns_pct_from_ledger(ledger_valve)
                            eq = ds_valve['equity']
                            total_ret = eq.iloc[-1] / eq.iloc[0] - 1
                            years = max((eq.index[-1] - eq.index[0]).days / 365.25, 1)
                            ann_ret = (1 + total_ret) ** (1 / years) - 1
                            mdd = _mdd_from_daily_equity(eq)
                            dd = eq / eq.cummax() - 1
                            blocks = (~(dd < 0)).cumsum()
                            dd_dur = int((dd.groupby(blocks).cumcount() + 1).where(dd < 0).max() or 0)
                            num_trades = len(r)
                            win_rate = (r > 0).sum() / num_trades if num_trades > 0 else 0
                            avg_win = r[r > 0].mean() if win_rate > 0 else np.nan
                            avg_loss = r[r < 0].mean() if win_rate < 1 else np.nan
                            payoff = abs(avg_win / avg_loss) if avg_loss != 0 and not np.isnan(avg_win) else np.nan
                            daily_r = eq.pct_change().dropna()
                            sharpe = (daily_r.mean() * np.sqrt(252)) / daily_r.std() if daily_r.std() != 0 else np.nan
                            downside = daily_r[daily_r < 0]
                            sortino = (daily_r.mean() * np.sqrt(252)) / downside.std() if downside.std() != 0 else np.nan
                            ann_vol = daily_r.std() * np.sqrt(252) if len(daily_r) > 0 else np.nan
                            prof = r[r > 0].sum()
                            loss = abs(r[r < 0].sum())
                            pf = prof / loss if loss != 0 else np.nan
                            win_flag = r > 0
                            grp = (win_flag != win_flag.shift()).cumsum()
                            consec = win_flag.groupby(grp).cumcount() + 1
                            max_wins = int(consec[win_flag].max() if True in win_flag.values else 0)
                            max_losses = int(consec[~win_flag].max() if False in win_flag.values else 0)
                            result['metrics'] = {
                                'total_return': float(total_ret),
                                'annual_return': float(ann_ret),
                                'max_drawdown': float(mdd),
                                'max_drawdown_duration': dd_dur,
                                'calmar_ratio': float(ann_ret / abs(mdd)) if mdd < 0 else np.nan,
                                'num_trades': int(num_trades),
                                'win_rate': float(win_rate),
                                'avg_win': float(avg_win) if not np.isnan(avg_win) else np.nan,
                                'avg_loss': float(avg_loss) if not np.isnan(avg_loss) else np.nan,
                                'payoff_ratio': float(payoff) if not np.isnan(payoff) else np.nan,
                                'sharpe_ratio': float(sharpe) if not np.isnan(sharpe) else np.nan,
                                'sortino_ratio': float(sortino) if not np.isnan(sortino) else np.nan,
                                'max_consecutive_wins': max_wins,
                                'max_consecutive_losses': max_losses,
                                'annualized_volatility': float(ann_vol) if not np.isnan(ann_vol) else np.nan,
                                'profit_factor': float(pf) if not np.isnan(pf) else np.nan,
                            }
                        
                        # 3) 給 UI 一個旗標與參數，便於顯示「已套用」
                        result['_risk_valve_applied'] = True
                        result['_risk_valve_params'] = {
                            'cap': float(risk_cap),
                            'atr_ratio': float(atr_ratio),
                            'atr20_last': float(atr_20_valid.iloc[-1]) if len(atr_20_valid) > 0 else None,
                            'atr60_last': float(atr_60_valid.iloc[-1]) if len(atr_60_valid) > 0 else None,
                        }
                        
                        true_days = int(mask_aligned.sum())
                        logger.info(f"[{strat}] 全局風險閥門已套用（逐日），風險天數={true_days}, CAP={risk_cap:.2f}")
                    else:
                        logger.warning(f"[{strat}] 風險閥門重算沒有返回結果")
        
        results[strat] = result
    
    # 使用第一個策略的數據作為主要顯示數據
    first_strat = list(results.keys())[0] if results else strategy_names[0]
    first_smaa_src = param_presets[first_strat].get("smaa_source", "Self")
    df_raw_main, _ = load_data(ticker, start_date, end_date if end_date else None, smaa_source=first_smaa_src)
    
    # 統一使用 orient="split" 序列化，確保一致性
    payload = {
        'results': results, 
